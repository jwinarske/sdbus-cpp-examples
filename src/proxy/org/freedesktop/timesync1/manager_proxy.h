
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__src_proxy_org_freedesktop_timesync1_manager_proxy_h__proxy__H__
#define __sdbuscpp__src_proxy_org_freedesktop_timesync1_manager_proxy_h__proxy__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace freedesktop {
namespace timesync1 {

class Manager_proxy {
 public:
  static constexpr const char* INTERFACE_NAME =
      "org.freedesktop.timesync1.Manager";

 protected:
  Manager_proxy(sdbus::IProxy& proxy) : m_proxy(proxy) {}

  Manager_proxy(const Manager_proxy&) = delete;
  Manager_proxy& operator=(const Manager_proxy&) = delete;
  Manager_proxy(Manager_proxy&&) = delete;
  Manager_proxy& operator=(Manager_proxy&&) = delete;

  ~Manager_proxy() = default;

  void registerProxy() {}

 public:
  void SetRuntimeNTPServers(const std::vector<std::string>& runtime_servers) {
    m_proxy.callMethod("SetRuntimeNTPServers")
        .onInterface(INTERFACE_NAME)
        .withArguments(runtime_servers);
  }

 public:
  std::vector<std::string> LinkNTPServers() {
    return m_proxy.getProperty("LinkNTPServers")
        .onInterface(INTERFACE_NAME)
        .get<std::vector<std::string>>();
  }

  std::vector<std::string> SystemNTPServers() {
    return m_proxy.getProperty("SystemNTPServers")
        .onInterface(INTERFACE_NAME)
        .get<std::vector<std::string>>();
  }

  std::vector<std::string> RuntimeNTPServers() {
    return m_proxy.getProperty("RuntimeNTPServers")
        .onInterface(INTERFACE_NAME)
        .get<std::vector<std::string>>();
  }

  std::vector<std::string> FallbackNTPServers() {
    return m_proxy.getProperty("FallbackNTPServers")
        .onInterface(INTERFACE_NAME)
        .get<std::vector<std::string>>();
  }

  std::string ServerName() {
    return m_proxy.getProperty("ServerName")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  sdbus::Struct<int32_t, std::vector<uint8_t>> ServerAddress() {
    return m_proxy.getProperty("ServerAddress")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::Struct<int32_t, std::vector<uint8_t>>>();
  }

  uint64_t RootDistanceMaxUSec() {
    return m_proxy.getProperty("RootDistanceMaxUSec")
        .onInterface(INTERFACE_NAME)
        .get<uint64_t>();
  }

  uint64_t PollIntervalMinUSec() {
    return m_proxy.getProperty("PollIntervalMinUSec")
        .onInterface(INTERFACE_NAME)
        .get<uint64_t>();
  }

  uint64_t PollIntervalMaxUSec() {
    return m_proxy.getProperty("PollIntervalMaxUSec")
        .onInterface(INTERFACE_NAME)
        .get<uint64_t>();
  }

  uint64_t PollIntervalUSec() {
    return m_proxy.getProperty("PollIntervalUSec")
        .onInterface(INTERFACE_NAME)
        .get<uint64_t>();
  }

  sdbus::Struct<uint32_t,
                uint32_t,
                uint32_t,
                uint32_t,
                int32_t,
                uint64_t,
                uint64_t,
                std::vector<uint8_t>,
                uint64_t,
                uint64_t,
                uint64_t,
                uint64_t,
                bool,
                uint64_t,
                uint64_t>
  NTPMessage() {
    return m_proxy.getProperty("NTPMessage")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::Struct<uint32_t, uint32_t, uint32_t, uint32_t, int32_t,
                           uint64_t, uint64_t, std::vector<uint8_t>, uint64_t,
                           uint64_t, uint64_t, uint64_t, bool, uint64_t,
                           uint64_t>>();
  }

  int64_t Frequency() {
    return m_proxy.getProperty("Frequency")
        .onInterface(INTERFACE_NAME)
        .get<int64_t>();
  }

 private:
  sdbus::IProxy& m_proxy;
};

}  // namespace timesync1
}  // namespace freedesktop
}  // namespace org

#endif
