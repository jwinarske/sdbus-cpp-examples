
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__src_proxy_org_freedesktop_NetworkManager_Device_device_proxy_h__proxy__H__
#define __sdbuscpp__src_proxy_org_freedesktop_NetworkManager_Device_device_proxy_h__proxy__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace freedesktop {
namespace NetworkManager {

class Device_proxy {
 public:
  static constexpr const char* INTERFACE_NAME =
      "org.freedesktop.NetworkManager.Device";

 protected:
  Device_proxy(sdbus::IProxy& proxy) : m_proxy(proxy) {}

  Device_proxy(const Device_proxy&) = delete;
  Device_proxy& operator=(const Device_proxy&) = delete;
  Device_proxy(Device_proxy&&) = delete;
  Device_proxy& operator=(Device_proxy&&) = delete;

  ~Device_proxy() = default;

  void registerProxy() {
    m_proxy.uponSignal("StateChanged")
        .onInterface(INTERFACE_NAME)
        .call([this](const uint32_t& new_state, const uint32_t& old_state,
                     const uint32_t& reason) {
          this->onStateChanged(new_state, old_state, reason);
        });
  }

  virtual void onStateChanged(const uint32_t& new_state,
                              const uint32_t& old_state,
                              const uint32_t& reason) = 0;

 public:
  void Reapply(
      const std::map<std::string, std::map<std::string, sdbus::Variant>>&
          connection,
      const uint64_t& version_id,
      const uint32_t& flags) {
    m_proxy.callMethod("Reapply")
        .onInterface(INTERFACE_NAME)
        .withArguments(connection, version_id, flags);
  }

  std::tuple<std::map<std::string, std::map<std::string, sdbus::Variant>>,
             uint64_t>
  GetAppliedConnection(const uint32_t& flags) {
    std::tuple<std::map<std::string, std::map<std::string, sdbus::Variant>>,
               uint64_t>
        result;
    m_proxy.callMethod("GetAppliedConnection")
        .onInterface(INTERFACE_NAME)
        .withArguments(flags)
        .storeResultsTo(result);
    return result;
  }

  void Disconnect() {
    m_proxy.callMethod("Disconnect").onInterface(INTERFACE_NAME);
  }

  void Delete() { m_proxy.callMethod("Delete").onInterface(INTERFACE_NAME); }

 public:
  std::string Udi() {
    return m_proxy.getProperty("Udi")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  std::string Path() {
    return m_proxy.getProperty("Path")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  std::string Interface() {
    return m_proxy.getProperty("Interface")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  std::string IpInterface() {
    return m_proxy.getProperty("IpInterface")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  std::string Driver() {
    return m_proxy.getProperty("Driver")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  std::string DriverVersion() {
    return m_proxy.getProperty("DriverVersion")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  std::string FirmwareVersion() {
    return m_proxy.getProperty("FirmwareVersion")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  uint32_t Capabilities() {
    return m_proxy.getProperty("Capabilities")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  uint32_t Ip4Address() {
    return m_proxy.getProperty("Ip4Address")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  uint32_t State() {
    return m_proxy.getProperty("State")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  sdbus::Struct<uint32_t, uint32_t> StateReason() {
    return m_proxy.getProperty("StateReason")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::Struct<uint32_t, uint32_t>>();
  }

  sdbus::ObjectPath ActiveConnection() {
    return m_proxy.getProperty("ActiveConnection")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::ObjectPath>();
  }

  sdbus::ObjectPath Ip4Config() {
    return m_proxy.getProperty("Ip4Config")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::ObjectPath>();
  }

  sdbus::ObjectPath Dhcp4Config() {
    return m_proxy.getProperty("Dhcp4Config")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::ObjectPath>();
  }

  sdbus::ObjectPath Ip6Config() {
    return m_proxy.getProperty("Ip6Config")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::ObjectPath>();
  }

  sdbus::ObjectPath Dhcp6Config() {
    return m_proxy.getProperty("Dhcp6Config")
        .onInterface(INTERFACE_NAME)
        .get<sdbus::ObjectPath>();
  }

  bool Managed() {
    return m_proxy.getProperty("Managed")
        .onInterface(INTERFACE_NAME)
        .get<bool>();
  }

  void Managed(const bool& value) {
    m_proxy.setProperty("Managed").onInterface(INTERFACE_NAME).toValue(value);
  }

  bool Autoconnect() {
    return m_proxy.getProperty("Autoconnect")
        .onInterface(INTERFACE_NAME)
        .get<bool>();
  }

  void Autoconnect(const bool& value) {
    m_proxy.setProperty("Autoconnect")
        .onInterface(INTERFACE_NAME)
        .toValue(value);
  }

  bool FirmwareMissing() {
    return m_proxy.getProperty("FirmwareMissing")
        .onInterface(INTERFACE_NAME)
        .get<bool>();
  }

  bool NmPluginMissing() {
    return m_proxy.getProperty("NmPluginMissing")
        .onInterface(INTERFACE_NAME)
        .get<bool>();
  }

  uint32_t DeviceType() {
    return m_proxy.getProperty("DeviceType")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  std::vector<sdbus::ObjectPath> AvailableConnections() {
    return m_proxy.getProperty("AvailableConnections")
        .onInterface(INTERFACE_NAME)
        .get<std::vector<sdbus::ObjectPath>>();
  }

  std::string PhysicalPortId() {
    return m_proxy.getProperty("PhysicalPortId")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  uint32_t Mtu() {
    return m_proxy.getProperty("Mtu")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  uint32_t Metered() {
    return m_proxy.getProperty("Metered")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  std::vector<std::map<std::string, sdbus::Variant>> LldpNeighbors() {
    return m_proxy.getProperty("LldpNeighbors")
        .onInterface(INTERFACE_NAME)
        .get<std::vector<std::map<std::string, sdbus::Variant>>>();
  }

  bool Real() {
    return m_proxy.getProperty("Real").onInterface(INTERFACE_NAME).get<bool>();
  }

  uint32_t Ip4Connectivity() {
    return m_proxy.getProperty("Ip4Connectivity")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  uint32_t Ip6Connectivity() {
    return m_proxy.getProperty("Ip6Connectivity")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  uint32_t InterfaceFlags() {
    return m_proxy.getProperty("InterfaceFlags")
        .onInterface(INTERFACE_NAME)
        .get<uint32_t>();
  }

  std::string HwAddress() {
    return m_proxy.getProperty("HwAddress")
        .onInterface(INTERFACE_NAME)
        .get<std::string>();
  }

  std::vector<sdbus::ObjectPath> Ports() {
    return m_proxy.getProperty("Ports")
        .onInterface(INTERFACE_NAME)
        .get<std::vector<sdbus::ObjectPath>>();
  }

 private:
  sdbus::IProxy& m_proxy;
};

}  // namespace NetworkManager
}  // namespace freedesktop
}  // namespace org

#endif
